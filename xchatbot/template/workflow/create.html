{% extends "base2.html" %}
{% load static %}
{% block title %}Chatbot Builder - Visual Workflow{% endblock %}

{% block content %}
<style>
    :root {
        --background: #121212;
        --surface: #1e1e1e;
        --surface-hover: #2c2c2c;
        --surface-light: #3a3a3a;
        --primary: #6e8efb;
        --primary-hover: #5a73e5;
        --primary-light: #a777e3;
        --secondary: #22c55e;
        --secondary-hover: #16a34a;
        --text: #f3f4f6;
        --text-secondary: #d1d5db;
        --text-muted: #9ca3af;
        --border: #2c2c2c;
        --border-light: #3a3a3a;
        --success: #22c55e;
        --warning: #eab308;
        --error: #ef4444;
        --accent: #8b5cf6;
        --shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
        --shadow-lg: 0 12px 28px rgba(0, 0, 0, 0.35);
    }

    .builder-container {
        display: flex;
        height: 100vh;
        position: relative;
        background: var(--background);
    }

    /* Left Sidebar - Component Palette */
    .component-palette {
        width: 280px;
        background: var(--surface);
        border-right: 1px solid var(--border);
        padding: 20px;
        overflow-y: auto;
        z-index: 10;
    }

    .palette-header {
        display: flex;
        align-items: center;
        gap: 12px;
        margin-bottom: 24px;
        padding-bottom: 16px;
        border-bottom: 1px solid var(--border);
    }

    .palette-title {
        font-size: 18px;
        font-weight: 600;
        color: var(--text);
    }

    .component-category {
        margin-bottom: 24px;
    }

    .category-title {
        font-size: 14px;
        font-weight: 500;
        color: var(--text-secondary);
        margin-bottom: 12px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
    }

    .component-item {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 12px 16px;
        background: var(--surface-light);
        border: 1px solid var(--border);
        border-radius: 8px;
        margin-bottom: 8px;
        cursor: grab;
        transition: all 0.2s ease;
        position: relative;
    }

    .component-item:hover {
        background: var(--surface-hover);
        border-color: var(--primary);
        transform: translateY(-1px);
        box-shadow: var(--shadow);
    }

    .component-item:active {
        cursor: grabbing;
    }

    .component-icon {
        width: 24px;
        height: 24px;
        background: var(--primary);
        border-radius: 6px;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-size: 12px;
        font-weight: 600;
    }

    .component-name {
        font-size: 14px;
        font-weight: 500;
        color: var(--text);
    }

    .component-desc {
        font-size: 12px;
        color: var(--text-muted);
        margin-top: 2px;
    }

    /* Main Canvas Area */
    .canvas-container {
        flex: 1;
        display: flex;
        flex-direction: column;
        background: var(--background);
        position: relative;
    }

    .canvas-header {
        background: var(--surface);
        border-bottom: 1px solid var(--border);
        padding: 16px 24px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        z-index: 5;
    }

    .canvas-title {
        font-size: 16px;
        font-weight: 600;
        color: var(--text);
    }

    .canvas-actions {
        display: flex;
        gap: 12px;
    }

    .btn {
        padding: 8px 16px;
        border-radius: 6px;
        border: none;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .btn-primary {
        background: var(--primary);
        color: white;
    }

    .btn-primary:hover {
        background: var(--primary-hover);
    }

    .btn-secondary {
        background: var(--surface-light);
        color: var(--text);
        border: 1px solid var(--border);
    }

    .btn-secondary:hover {
        background: var(--surface-hover);
    }

    .canvas-workspace {
        flex: 1;
        position: relative;
        overflow: hidden;
        background: 
            radial-gradient(circle at 20px 20px, var(--border) 1px, transparent 0),
            radial-gradient(circle at 20px 20px, var(--border) 1px, transparent 0);
        background-size: 40px 40px;
        background-position: 0 0, 20px 20px;
    }

    .workflow-canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        padding: 40px;
    }

    /* Workflow Nodes */
    .workflow-node {
        position: absolute;
        background: var(--surface);
        border: 2px solid var(--border);
        border-radius: 12px;
        padding: 20px;
        min-width: 250px;
        cursor: move;
        transition: all 0.2s ease;
        box-shadow: var(--shadow);
    }

    .workflow-node:hover {
        border-color: var(--primary);
        box-shadow: var(--shadow-lg);
    }

    .workflow-node.selected {
        border-color: var(--primary);
        box-shadow: 0 0 0 4px rgba(110, 142, 251, 0.2);
    }

    .node-header {
        display: flex;
        align-items: center;
        gap: 12px;
        margin-bottom: 16px;
    }

    .node-icon {
        width: 32px;
        height: 32px;
        background: var(--primary);
        border-radius: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-size: 16px;
        font-weight: 600;
    }

    .node-title {
        font-size: 16px;
        font-weight: 600;
        color: var(--text);
    }

    .node-content {
        color: var(--text-secondary);
        font-size: 14px;
    }

    .node-input {
        width: 100%;
        padding: 8px 12px;
        background: var(--surface-light);
        border: 1px solid var(--border);
        border-radius: 6px;
        color: var(--text);
        font-size: 14px;
        margin-top: 8px;
    }

    .node-input:focus {
        outline: none;
        border-color: var(--primary);
    }

    .node-select {
        width: 100%;
        padding: 8px 12px;
        background: var(--surface-light);
        border: 1px solid var(--border);
        border-radius: 6px;
        color: var(--text);
        font-size: 14px;
        margin-top: 8px;
    }

    /* Connection Points */
    .connection-point {
        position: absolute;
        width: 12px;
        height: 12px;
        background: var(--primary);
        border: 2px solid var(--surface);
        border-radius: 50%;
        cursor: pointer;
        transition: all 0.2s ease;
    }

    .connection-point:hover {
        transform: scale(1.3);
        box-shadow: 0 0 0 4px rgba(110, 142, 251, 0.3);
    }

    .connection-point.input {
        left: -6px;
        top: 50%;
        transform: translateY(-50%);
    }

    .connection-point.output {
        right: -6px;
        top: 50%;
        transform: translateY(-50%);
    }

    /* Right Panel - Properties */
    .properties-panel {
        width: 320px;
        background: var(--surface);
        border-left: 1px solid var(--border);
        padding: 20px;
        overflow-y: auto;
        z-index: 10;
    }

    .properties-header {
        margin-bottom: 24px;
        padding-bottom: 16px;
        border-bottom: 1px solid var(--border);
    }

    .properties-title {
        font-size: 18px;
        font-weight: 600;
        color: var(--text);
        margin-bottom: 8px;
    }

    .properties-subtitle {
        font-size: 14px;
        color: var(--text-muted);
    }

    .property-group {
        margin-bottom: 24px;
    }

    .property-label {
        display: block;
        font-size: 14px;
        font-weight: 500;
        color: var(--text-secondary);
        margin-bottom: 8px;
    }

    .property-input {
        width: 100%;
        padding: 10px 12px;
        background: var(--surface-light);
        border: 1px solid var(--border);
        border-radius: 6px;
        color: var(--text);
        font-size: 14px;
    }

    .property-input:focus {
        outline: none;
        border-color: var(--primary);
    }

    .property-textarea {
        width: 100%;
        padding: 10px 12px;
        background: var(--surface-light);
        border: 1px solid var(--border);
        border-radius: 6px;
        color: var(--text);
        font-size: 14px;
        min-height: 80px;
        resize: vertical;
    }

    .property-toggle {
        display: flex;
        align-items: center;
        gap: 12px;
        margin-bottom: 12px;
    }

    .toggle-switch {
        position: relative;
        width: 44px;
        height: 24px;
        background: var(--surface-light);
        border-radius: 12px;
        cursor: pointer;
        transition: background 0.2s ease;
    }

    .toggle-switch.active {
        background: var(--primary);
    }

    .toggle-slider {
        position: absolute;
        top: 2px;
        left: 2px;
        width: 20px;
        height: 20px;
        background: white;
        border-radius: 50%;
        transition: transform 0.2s ease;
    }

    .toggle-switch.active .toggle-slider {
        transform: translateX(20px);
    }

    .model-card {
        background: var(--surface-light);
        border: 1px solid var(--border);
        border-radius: 8px;
        padding: 16px;
        margin-bottom: 12px;
        cursor: pointer;
        transition: all 0.2s ease;
    }

    .model-card:hover {
        border-color: var(--primary);
        background: var(--surface-hover);
    }

    .model-card.selected {
        border-color: var(--primary);
        background: rgba(110, 142, 251, 0.1);
    }

    .model-name {
        font-size: 14px;
        font-weight: 600;
        color: var(--text);
        margin-bottom: 4px;
    }

    .model-desc {
        font-size: 12px;
        color: var(--text-muted);
    }

    .floating-toolbar {
        position: absolute;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: var(--surface);
        border: 1px solid var(--border);
        border-radius: 8px;
        padding: 8px;
        display: flex;
        gap: 8px;
        box-shadow: var(--shadow-lg);
        z-index: 20;
    }

    .toolbar-btn {
        padding: 8px 12px;
        background: transparent;
        border: none;
        border-radius: 6px;
        color: var(--text);
        cursor: pointer;
        transition: all 0.2s ease;
        font-size: 14px;
    }

    .toolbar-btn:hover {
        background: var(--surface-hover);
    }

    .zoom-controls {
        position: absolute;
        bottom: 20px;
        right: 20px;
        display: flex;
        gap: 8px;
        background: var(--surface);
        border: 1px solid var(--border);
        border-radius: 8px;
        padding: 8px;
        box-shadow: var(--shadow);
    }

    .zoom-btn {
        width: 36px;
        height: 36px;
        background: transparent;
        border: none;
        border-radius: 6px;
        color: var(--text);
        cursor: pointer;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 18px;
    }

    .zoom-btn:hover {
        background: var(--surface-hover);
    }

    /* Animations */
    @keyframes nodeAppear {
        from {
            opacity: 0;
            transform: scale(0.8);
        }
        to {
            opacity: 1;
            transform: scale(1);
        }
    }

    .workflow-node.new {
        animation: nodeAppear 0.3s ease;
    }

    /* Mobile Responsive */
    @media (max-width: 768px) {
        .component-palette {
            width: 240px;
        }
        
        .properties-panel {
            width: 280px;
        }
    }
</style>
<style>
    .main-content {
    margin-left: 0rem;
}
</style>
<!-- Main Content -->
<div id="mainContent" class="main-content">
    <div class="builder-container">
        <!-- Left Sidebar - Component Palette -->
        <div style="overflow-y: scroll; scrollbar-width: none; -ms-overflow-style: none; height: 100%;">
        <div class="component-palette">
            <div class="palette-header">
                <div class="palette-title">ü§ñ Bot Builder</div>
            </div>

            <div class="component-category">
                <div class="category-title">Core Setup</div>
                <div class="component-item" draggable="true" data-type="bot-config">
                    <div class="component-icon">üîß</div>
                    <div>
                        <div class="component-name">Bot Configuration</div>
                        <div class="component-desc">Set name & basic settings</div>
                    </div>
                </div>
                <div class="component-item" draggable="true" data-type="knowledge-base">
                    <div class="component-icon">üìö</div>
                    <div>
                        <div class="component-name">Knowledge Base</div>
                        <div class="component-desc">Define bot's knowledge</div>
                    </div>
                </div>
                <div class="component-item" draggable="true" data-type="web-scraper">
                    <div class="component-icon">üåê</div>
                    <div>
                        <div class="component-name">Web Scraper</div>
                        <div class="component-desc">Scrape URLs for data</div>
                    </div>
                </div>
            </div>

            <div class="component-category">
                <div class="category-title">AI Models</div>
                <div class="component-item" draggable="true" data-type="llm-brain">
                    <div class="component-icon">üß†</div>
                    <div>
                        <div class="component-name">LLM Brain</div>
                        <div class="component-desc">Choose AI model</div>
                    </div>
                </div>
                <div class="component-item" draggable="true" data-type="server-config">
                    <div class="component-icon">üñ•Ô∏è</div>
                    <div>
                        <div class="component-name">Server Setup</div>
                        <div class="component-desc">Configure hosting</div>
                    </div>
                </div>
            </div>
              <div class="component-category">
                <div class="category-title">Integrations</div>
                <div class="component-item" draggable="true" data-type="email-sender">
                    <div class="component-icon">üìß</div>
                    <div>
                        <div class="component-name">Email Sender</div>
                        <div class="component-desc">Send automated emails</div>
                    </div>
                </div>
                <div class="component-item" draggable="true" data-type="form-handler">
                    <div class="component-icon">üìù</div>
                    <div>
                        <div class="component-name">Form Handler</div>
                        <div class="component-desc">Process form submissions</div>
                    </div>
                </div>
                <div class="component-item" draggable="true" data-type="webhook">
                    <div class="component-icon">üîó</div>
                    <div>
                        <div class="component-name">Webhook</div>
                        <div class="component-desc">External integrations</div>
                    </div>
                </div>
            </div>
          
        </div>
        </div>
        <!-- Main Canvas Area -->
        <div class="canvas-container">
            <div class="canvas-header">
                <div class="canvas-title">Visual Workflow Builder</div>
                <div class="canvas-actions">
                    <button class="btn btn-secondary">üíæ Save</button>
                    <button class="btn btn-secondary">üëÅÔ∏è Preview</button>
                    <button class="btn btn-primary">üöÄ Deploy</button>
                </div>
            </div>

            <div class="canvas-workspace">
                <div class="workflow-canvas" id="workflowCanvas">
                    <!-- Floating Toolbar -->
                    <div class="floating-toolbar">
                        <button class="toolbar-btn">‚Ü∂ Undo</button>
                        <button class="toolbar-btn">‚Ü∑ Redo</button>
                        <button class="toolbar-btn">üóëÔ∏è Delete</button>
                        <button class="toolbar-btn">üìã Copy</button>
                    </div>

                    <!-- Sample Workflow Nodes -->
                    <div class="workflow-node" style="top: 100px; left: 50px;" data-node-id="start">
                        <div class="connection-point output"></div>
                        <div class="node-header">
                            <div class="node-icon">üöÄ</div>
                            <div class="node-title">Start</div>
                        </div>
                        <div class="node-content">
                            Drag components from the left panel to build your chatbot workflow
                        </div>
                    </div>
                </div>

                <!-- Zoom Controls -->
                <div class="zoom-controls">
                    <button class="zoom-btn">‚àí</button>
                    <button class="zoom-btn">+</button>
                    <button class="zoom-btn">üîç</button>
                </div>
            </div>
        </div>

        <!-- Right Panel - Properties -->
        <div class="properties-panel">
            <div class="properties-header">
                <div class="properties-title">Properties</div>
                <div class="properties-subtitle">Configure selected component</div>
            </div>

            <!-- <div class="property-group">
                <label class="property-label">Bot Name</label>
                <input type="text" class="property-input" placeholder="Enter bot name...">
            </div>

            <div class="property-group">
                <label class="property-label">Bot Description</label>
                <textarea class="property-textarea" placeholder="Describe what your bot does..."></textarea>
            </div> -->
<!-- 
            <div class="property-group">
                <label class="property-label">AI Model</label>
                <div class="model-card selected">
                    <div class="model-name">GPT-4 Turbo</div>
                    <div class="model-desc">Most capable model for complex tasks</div>
                </div>
                <div class="model-card">
                    <div class="model-name">GPT-3.5 Turbo</div>
                    <div class="model-desc">Fast and efficient for most tasks</div>
                </div>
                <div class="model-card">
                    <div class="model-name">Claude 3</div>
                    <div class="model-desc">Excellent for analysis and reasoning</div>
                </div>
            </div> -->
<div class="property-group">
                <label class="property-label">Knowledge Source URL</label>
                <input type="url" class="property-input" placeholder="https://example.com">
                <button class="btn btn-primary" style="margin-top: 8px; width: 100%;">
                    üîç Scan Website
                </button>
            </div>
              <div class="property-group">
    <label class="property-label">Your Actions</label>
    <div class="actions-list"></div>
</div>


            <!-- <div class="property-group">
                <label class="property-label">Features</label>
                <div class="property-toggle">
                    <div class="toggle-switch active">
                        <div class="toggle-slider"></div>
                    </div>
                    <span>Email Notifications</span>
                </div>
                <div class="property-toggle">
                    <div class="toggle-switch">
                        <div class="toggle-slider"></div>
                    </div>
                    <span>Form Processing</span>
                </div>
                <div class="property-toggle">
                    <div class="toggle-switch active">
                        <div class="toggle-slider"></div>
                    </div>
                    <span>Web Scraping</span>
                </div>
                <div class="property-toggle">
                    <div class="toggle-switch">
                        <div class="toggle-slider"></div>
                    </div>
                    <span>API Integrations</span>
                </div>
            </div> -->

            
        </div>
    </div>
</div>

<script>
// Drag and Drop functionality with auto-connect and undo/redo
document.addEventListener('DOMContentLoaded', function() {
    let draggedElement = null;
    let isDragging = false;
    let nodeCounter = 0;
    let connections = [];
    let connectionCounter = 0;
    
    // Undo/Redo system
    let history = [];
    let historyIndex = -1;
    const MAX_HISTORY = 50;

    // Save state for undo/redo
    function saveState() {
        const state = {
            nodes: Array.from(document.querySelectorAll('.workflow-node')).map(node => ({
                id: node.dataset.nodeId,
                type: node.querySelector('.node-title').textContent,
                icon: node.querySelector('.node-icon').textContent,
                position: {
                    x: parseInt(node.style.left),
                    y: parseInt(node.style.top)
                },
                inputs: Array.from(node.querySelectorAll('.node-input, .node-select')).map(input => ({
                    type: input.tagName.toLowerCase(),
                    value: input.value,
                    placeholder: input.placeholder
                }))
            })),
            connections: [...connections]
        };
        
        // Remove any states after current index
        history = history.slice(0, historyIndex + 1);
        history.push(state);
        
        // Limit history size
        if (history.length > MAX_HISTORY) {
            history.shift();
        } else {
            historyIndex++;
        }
    }

    // Restore state from history
    function restoreState(state) {
        // Clear current canvas
        document.querySelectorAll('.workflow-node').forEach(node => node.remove());
        document.querySelectorAll('.connection-line').forEach(line => line.remove());
        
        // Restore nodes
        state.nodes.forEach(nodeData => {
            const node = createWorkflowNodeFromData(nodeData);
            document.getElementById('workflowCanvas').appendChild(node);
        });
        
        // Restore connections
        connections = [...state.connections];
        connections.forEach(conn => {
            drawConnection(conn.from, conn.to, conn.id);
        });
        
        // Update counter
        nodeCounter = Math.max(...state.nodes.map(n => parseInt(n.id.split('-')[1])), 0);
    }

    // Undo function
    function undo() {
        if (historyIndex > 0) {
            historyIndex--;
            restoreState(history[historyIndex]);
        }
    }

    // Redo function
    function redo() {
        if (historyIndex < history.length - 1) {
            historyIndex++;
            restoreState(history[historyIndex]);
        }
    }

    // Component palette drag start
    document.querySelectorAll('.component-item').forEach(item => {
    // Make items draggable permanently
    item.draggable = true;
    
    item.addEventListener('dragstart', function(e) {
        draggedElement = this;
        isDragging = true;
        this.style.opacity = '0.5';
        
        // Set drag data
        e.dataTransfer.setData('text/plain', this.dataset.type);
        e.dataTransfer.effectAllowed = 'copy';
    });

    item.addEventListener('dragend', function(e) {
        this.style.opacity = '1';
        isDragging = false;
        draggedElement = null;
    });
});

    // Canvas drop zone
    const workflowCanvas = document.getElementById('workflowCanvas');
    
    workflowCanvas.addEventListener('dragover', function(e) {
        e.preventDefault();
    });

    workflowCanvas.addEventListener('drop', function(e) {
        e.preventDefault();
        
        if (draggedElement && isDragging) {
            const rect = workflowCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left - 125; // Center the node
            const y = e.clientY - rect.top - 60;
            
            createWorkflowNode(draggedElement.dataset.type, x, y);
            saveState(); // Save state after adding node
        }
    });

    // Auto-connect nodes in sequence (always connect to the last added node)
    function autoConnectNodes(newNode) {
        const allNodes = document.querySelectorAll('.workflow-node');
        
        // If this is the first node, no connection needed
        if (allNodes.length <= 1) return;
        
        // Find the previous node (the one added before this one)
        let previousNode = null;
        let maxNodeId = 0;
        
        allNodes.forEach(node => {
            if (node === newNode) return;
            
            const nodeIdNum = parseInt(node.dataset.nodeId.split('-')[1]);
            if (nodeIdNum > maxNodeId) {
                maxNodeId = nodeIdNum;
                previousNode = node;
            }
        });
        
        // If we found a previous node, connect to it
        if (previousNode) {
            const fromNodeId = previousNode.dataset.nodeId;
            const toNodeId = newNode.dataset.nodeId;
            
            // Check if connection already exists
            const existingConnection = connections.find(conn => 
                (conn.from === fromNodeId && conn.to === toNodeId) ||
                (conn.from === toNodeId && conn.to === fromNodeId)
            );
            
            if (!existingConnection) {
                // Add a small delay to ensure the node is fully rendered
                setTimeout(() => {
                    createConnection(fromNodeId, toNodeId);
                }, 100);
            }
        }
    }

    // Create connection between nodes
    function createConnection(fromNodeId, toNodeId) {
        connectionCounter++;
        const connectionId = 'conn-' + connectionCounter;
        
        connections.push({
            id: connectionId,
            from: fromNodeId,
            to: toNodeId
        });
        
        drawConnection(fromNodeId, toNodeId, connectionId);
    }

// Fix 2: Updated connection line drawing with proper z-index (replace existing)
function drawConnection(fromNodeId, toNodeId, connectionId) {
    const fromNode = document.querySelector(`[data-node-id="${fromNodeId}"]`);
    const toNode = document.querySelector(`[data-node-id="${toNodeId}"]`);
    
    if (!fromNode || !toNode) return;
    
    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.className = 'connection-line';
    svg.dataset.connectionId = connectionId;
    svg.style.position = 'absolute';
    svg.style.top = '0';
    svg.style.left = '0';
    svg.style.width = '100%';
    svg.style.height = '100%';
    svg.style.pointerEvents = 'none';
    svg.style.zIndex = '0'; // Changed from '1' to '0' to put lines behind nodes
    
    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    path.style.fill = 'none';
    path.style.stroke = 'url(#connectionGradient)';
    path.style.strokeWidth = '3';
    path.style.filter = 'drop-shadow(0 0 6px rgba(59, 130, 246, 0.4))';
    
    // Create gradient definition
    const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
    const gradient = document.createElementNS('http://www.w3.org/2000/svg', 'linearGradient');
    gradient.id = `connectionGradient-${connectionId}`;
    gradient.setAttribute('x1', '0%');
    gradient.setAttribute('y1', '0%');
    gradient.setAttribute('x2', '100%');
    gradient.setAttribute('y2', '0%');
    
    const stop1 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
    stop1.setAttribute('offset', '0%');
    stop1.style.stopColor = '#3b82f6';
    stop1.style.stopOpacity = '0.8';
    
    const stop2 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
    stop2.setAttribute('offset', '50%');
    stop2.style.stopColor = '#1e40af';
    stop2.style.stopOpacity = '0.9';
    
    const stop3 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
    stop3.setAttribute('offset', '100%');
    stop3.style.stopColor = '#3b82f6';
    stop3.style.stopOpacity = '0.8';
    
    gradient.appendChild(stop1);
    gradient.appendChild(stop2);
    gradient.appendChild(stop3);
    defs.appendChild(gradient);
    
    // Update path stroke to use unique gradient
    path.style.stroke = `url(#connectionGradient-${connectionId})`;
    
    svg.appendChild(defs);
    svg.appendChild(path);
    
    // Add subtle pulsing animation
    const style = document.createElement('style');
    if (!document.querySelector('#connection-styles')) {
        style.id = 'connection-styles';
        style.textContent = `
            @keyframes pulse-path {
                0%, 100% { 
                    filter: drop-shadow(0 0 6px rgba(59, 130, 246, 0.4));
                    stroke-width: 3;
                }
                50% { 
                    filter: drop-shadow(0 0 10px rgba(59, 130, 246, 0.6));
                    stroke-width: 3.5;
                }
            }
            .connection-line path {
                animation: pulse-path 3s ease-in-out infinite;
            }
            .workflow-node {
                z-index: 10;
                position: relative;
            }
        `;
        document.head.appendChild(style);
    }
    
    workflowCanvas.appendChild(svg);
    
    // Update connection path immediately and smoothly
    requestAnimationFrame(() => {
        updateConnectionLine(svg, fromNode, toNode);
    });
}

// Fix 3: Improved connection line positioning (replace existing)
// Replace the updateConnectionLine function with this distance-aware version
function updateConnectionLine(svg, fromNode, toNode) {
    if (!svg || !fromNode || !toNode) return;
    
    // Get the current zoom level
    const canvasTransform = workflowCanvas.style.transform;
    const zoomMatch = canvasTransform.match(/scale\(([^)]+)\)/);
    const currentZoom = zoomMatch ? parseFloat(zoomMatch[1]) : 1;
    
    // Use node positions directly from style (more reliable for large distances)
    const fromLeft = parseInt(fromNode.style.left) || 0;
    const fromTop = parseInt(fromNode.style.top) || 0;
    const toLeft = parseInt(toNode.style.left) || 0;
    const toTop = parseInt(toNode.style.top) || 0;
    
    // Get node dimensions
    const fromRect = fromNode.getBoundingClientRect();
    const toRect = toNode.getBoundingClientRect();
    const nodeWidth = fromRect.width / currentZoom;
    const nodeHeight = fromRect.height / currentZoom;
    
    // Calculate connection points based on node positions
    const fromOutput = fromNode.querySelector('.connection-point.output');
    const toInput = toNode.querySelector('.connection-point.input');
    
    let fromX, fromY, toX, toY;
    
    if (fromOutput) {
        // Use connection point offset
        fromX = fromLeft + nodeWidth - 8;
        fromY = fromTop + nodeHeight / 2;
    } else {
        fromX = fromLeft + nodeWidth - 2;
        fromY = fromTop + nodeHeight / 2;
    }
    
    if (toInput) {
        // Use connection point offset
        toX = toLeft + 8;
        toY = toTop + nodeHeight / 2;
    } else {
        toX = toLeft + 2;
        toY = toTop + nodeHeight / 2;
    }
    
    // Calculate distance-based control points
    const distance = Math.sqrt(Math.pow(toX - fromX, 2) + Math.pow(toY - fromY, 2));
    const controlOffset = Math.min(Math.max(distance / 2.5, 80), 300);
    
    const controlX1 = fromX + controlOffset;
    const controlY1 = fromY;
    const controlX2 = toX - controlOffset;
    const controlY2 = toY;
    
    // Create smooth cubic bezier curve
    const pathData = `M ${fromX} ${fromY} C ${controlX1} ${controlY1}, ${controlX2} ${controlY2}, ${toX} ${toY}`;
    
    const path = svg.querySelector('path');
    if (path) {
        path.setAttribute('d', pathData);
    }
}

// Fix 4: Optimized connection updates during drag (replace existing)
function updateAllConnections() {
    // Use requestAnimationFrame for smooth updates
    requestAnimationFrame(() => {
        connections.forEach(conn => {
            const line = document.querySelector(`[data-connection-id="${conn.id}"]`);
            const fromNode = document.querySelector(`[data-node-id="${conn.from}"]`);
            const toNode = document.querySelector(`[data-node-id="${conn.to}"]`);
            
            if (line && fromNode && toNode) {
                updateConnectionLine(line, fromNode, toNode);
            }
        });
    });
}

    // Create workflow node from data (for undo/redo)
    function createWorkflowNodeFromData(nodeData) {
        const nodeTypes = {
            'Bot Configuration': { icon: 'üîß', type: 'bot-config' },
            'Knowledge Base': { icon: 'üìö', type: 'knowledge-base' },
            'Web Scraper': { icon: 'üåê', type: 'web-scraper' },
            'LLM Brain': { icon: 'üß†', type: 'llm-brain' },
            'Server Setup': { icon: 'üñ•Ô∏è', type: 'server-config' },
            'Email Sender': { icon: 'üìß', type: 'email-sender' },
            'Form Handler': { icon: 'üìù', type: 'form-handler' },
            'Webhook': { icon: 'üîó', type: 'webhook' }
        };

        const config = nodeTypes[nodeData.type];
        if (!config) return null;

        const node = document.createElement('div');
        node.className = 'workflow-node';
        node.style.top = nodeData.position.y + 'px';
        node.style.left = nodeData.position.x + 'px';
        node.dataset.nodeId = nodeData.id;

        const content = getNodeContent(config.type);
        node.innerHTML = `
            <div class="connection-point input"></div>
            <div class="connection-point output"></div>
            <div class="node-header">
                <div class="node-icon">${config.icon}</div>
                <div class="node-title">${nodeData.type}</div>
            </div>
            <div class="node-content">
                ${content}
            </div>
        `;

        // Restore input values
        const inputs = node.querySelectorAll('.node-input, .node-select');
        inputs.forEach((input, index) => {
            if (nodeData.inputs[index]) {
                input.value = nodeData.inputs[index].value;
            }
        });

        makeNodeDraggable(node);
        node.addEventListener('click', function(e) {
            e.stopPropagation();
            selectNode(node);
        });

        return node;
    }

    // Get node content HTML
    function getNodeContent(type) {
        const contentMap = {
            'bot-config': `
                <input type="text" class="node-input" placeholder="Bot Name">
                <textarea class="node-input" placeholder="Bot Description" rows="2"></textarea>
            `,
            'knowledge-base': `
                <textarea class="node-input" placeholder="Enter bot knowledge..." rows="3"></textarea>
            `,
            'web-scraper': `
                <input type="url" class="node-input" placeholder="URL to scrape">
                <button class="btn btn-primary" style="margin-top: 8px; width: 100%; padding: 6px;">Scan</button>
            `,
            'llm-brain': `
                <select class="node-select">
                    <option>GPT-4 Turbo</option>
                    <option>GPT-3.5 Turbo</option>
                    <option>Claude 3</option>
                </select>
            `,
            'server-config': `
                <select class="node-select">
                    <option>Auto-Scale Cloud</option>
                    <option>Dedicated Server</option>
                    <option>Shared Hosting</option>
                </select>
            `,
            'email-sender': `
                <input type="email" class="node-input" placeholder="SMTP Server">
                <input type="text" class="node-input" placeholder="Email Template">
            `,
            'form-handler': `
                <input type="text" class="node-input" placeholder="Form Fields">
                <select class="node-select">
                    <option>Save to Database</option>
                    <option>Send Email</option>
                    <option>Webhook</option>
                </select>
            `,
            'webhook': `
                <input type="url" class="node-input" placeholder="Webhook URL">
                <select class="node-select">
                    <option>POST</option>
                    <option>GET</option>
                    <option>PUT</option>
                </select>
            `
        };
        return contentMap[type] || '';
    }

    // Create workflow node
    function createWorkflowNode(type, x, y) {
        nodeCounter++;
        
        const nodeTypes = {
            'bot-config': {
                icon: 'üîß',
                title: 'Bot Configuration',
                content: `
                    <input type="text" class="node-input" placeholder="Bot Name">
                    <textarea class="node-input" placeholder="Bot Description" rows="2"></textarea>
                `
            },
            'knowledge-base': {
                icon: 'üìö',
                title: 'Knowledge Base',
                content: `
                    <textarea class="node-input" placeholder="Enter bot knowledge..." rows="3"></textarea>
                `
            },
            'web-scraper': {
                icon: 'üåê',
                title: 'Web Scraper',
                content: `
                    <input type="url" class="node-input" placeholder="URL to scrape">
                    <button class="btn btn-primary" style="margin-top: 8px; width: 100%; padding: 6px;">Scan</button>
                `
            },
            'llm-brain': {
                icon: 'üß†',
                title: 'LLM Brain',
                content: `
                    <select class="node-select">
                        <option>GPT-4 Turbo</option>
                        <option>GPT-3.5 Turbo</option>
                        <option>Claude 3</option>
                    </select>
                `
            },
            'server-config': {
                icon: 'üñ•Ô∏è',
                title: 'Server Setup',
                content: `
                    <select class="node-select">
                        <option>Auto-Scale Cloud</option>
                        <option>Dedicated Server</option>
                        <option>Shared Hosting</option>
                    </select>
                `
            },
            'email-sender': {
                icon: 'üìß',
                title: 'Email Sender',
                content: `
                    <input type="email" class="node-input" placeholder="SMTP Server">
                    <input type="text" class="node-input" placeholder="Email Template">
                `
            },
            'form-handler': {
                icon: 'üìù',
                title: 'Form Handler',
                content: `
                    <input type="text" class="node-input" placeholder="Form Fields">
                    <select class="node-select">
                        <option>Save to Database</option>
                        <option>Send Email</option>
                        <option>Webhook</option>
                    </select>
                `
            },
            'webhook': {
                icon: 'üîó',
                title: 'Webhook',
                content: `
                    <input type="url" class="node-input" placeholder="Webhook URL">
                    <select class="node-select">
                        <option>POST</option>
                        <option>GET</option>
                        <option>PUT</option>
                    </select>
                `
            }
        };

        const nodeConfig = nodeTypes[type];
        if (!nodeConfig) return;

        const node = document.createElement('div');
        node.className = 'workflow-node new';
        node.style.top = y + 'px';
        node.style.left = x + 'px';
        node.dataset.nodeId = 'node-' + nodeCounter;

        node.innerHTML = `
            <div class="connection-point input"></div>
            <div class="connection-point output"></div>
            <div class="node-header">
                <div class="node-icon">${nodeConfig.icon}</div>
                <div class="node-title">${nodeConfig.title}</div>
            </div>
            <div class="node-content">
                ${nodeConfig.content}
            </div>
        `;

        workflowCanvas.appendChild(node);

        // Auto-connect to nearby nodes
        autoConnectNodes(node);

        // Make node draggable
        makeNodeDraggable(node);

        // Add click selection
        node.addEventListener('click', function(e) {
            e.stopPropagation();
            selectNode(node);
        });

        // Remove 'new' class after animation
        setTimeout(() => {
            node.classList.remove('new');
        }, 300);
    }

    // Replace the makeNodeDraggable function with this smooth version
function makeNodeDraggable(node) {
    let isDragging = false;
    let startX, startY, startLeft, startTop;

    node.addEventListener('mousedown', function(e) {
        if (e.target.classList.contains('node-input') || 
            e.target.classList.contains('node-select') || 
            e.target.classList.contains('btn')) {
            return;
        }
        
        isDragging = true;
        startX = e.clientX;
        startY = e.clientY;
        startLeft = parseInt(node.style.left) || 0;
        startTop = parseInt(node.style.top) || 0;
        
        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mouseup', onMouseUp);
        
        e.preventDefault();
    });

    function onMouseMove(e) {
        if (!isDragging) return;
        
        const dx = e.clientX - startX;
        const dy = e.clientY - startY;
        
        node.style.left = (startLeft + dx) + 'px';
        node.style.top = (startTop + dy) + 'px';
    }

    function onMouseUp() {
        if (isDragging) {
            isDragging = false;
            updateAllConnections();
            saveState();
        }
        
        document.removeEventListener('mousemove', onMouseMove);
        document.removeEventListener('mouseup', onMouseUp);
    }
}
    // Node selection
    function selectNode(node) {
        document.querySelectorAll('.workflow-node').forEach(n => {
            n.classList.remove('selected');
        });
        node.classList.add('selected');
    }

    // Deselect when clicking canvas
    workflowCanvas.addEventListener('click', function(e) {
        if (e.target === workflowCanvas) {
            document.querySelectorAll('.workflow-node').forEach(n => {
                n.classList.remove('selected');
            });
        }
    });

    // Toggle switches
    document.querySelectorAll('.toggle-switch').forEach(toggle => {
        toggle.addEventListener('click', function() {
            this.classList.toggle('active');
        });
    });

    // Model card selection
    document.querySelectorAll('.model-card').forEach(card => {
        card.addEventListener('click', function() {
            document.querySelectorAll('.model-card').forEach(c => {
                c.classList.remove('selected');
            });
            this.classList.add('selected');
        });
    });

    // Zoom controls
    let zoomLevel = 1;
    const zoomButtons = document.querySelectorAll('.zoom-btn');
    
    if (zoomButtons.length >= 3) {
        zoomButtons[0].addEventListener('click', function() {
            zoomLevel = Math.max(0.5, zoomLevel - 0.1);
            updateZoom();
        });
        
        zoomButtons[1].addEventListener('click', function() {
            zoomLevel = Math.min(2, zoomLevel + 0.1);
            updateZoom();
        });
        
        zoomButtons[2].addEventListener('click', function() {
            zoomLevel = 1;
            updateZoom();
        });
    }

    function updateZoom() {
        workflowCanvas.style.transform = `scale(${zoomLevel})`;
        workflowCanvas.style.transformOrigin = 'center center';
    }

    // Toolbar actions
    document.querySelectorAll('.toolbar-btn').forEach((btn, index) => {
        btn.addEventListener('click', function() {
            const actions = ['undo', 'redo', 'delete', 'copy'];
            const action = actions[index];
            
            switch(action) {
                case 'undo':
                    undo();
                    break;
                case 'redo':
                    redo();
                    break;
                case 'delete':
                    const selected = document.querySelector('.workflow-node.selected');
                    if (selected) {
                        // Remove connected lines
                        const nodeId = selected.dataset.nodeId;
                        connections = connections.filter(conn => {
                            if (conn.from === nodeId || conn.to === nodeId) {
                                const line = document.querySelector(`[data-connection-id="${conn.id}"]`);
                                if (line) line.remove();
                                return false;
                            }
                            return true;
                        });
                        
                        selected.remove();
                        saveState();
                    }
                    break;
                case 'copy':
                    const selectedNode = document.querySelector('.workflow-node.selected');
                    if (selectedNode) {
                        // Create a copy offset by 20px
                        const rect = selectedNode.getBoundingClientRect();
                        const canvasRect = workflowCanvas.getBoundingClientRect();
                        const x = rect.left - canvasRect.left + 20;
                        const y = rect.top - canvasRect.top + 20;
                        
                        // Get the node type from its structure
                        const nodeIcon = selectedNode.querySelector('.node-icon').textContent;
                        const nodeTitle = selectedNode.querySelector('.node-title').textContent;
                        
                        // Map back to component type
                        const typeMap = {
                            'üîß': 'bot-config',
                            'üìö': 'knowledge-base',
                            'üåê': 'web-scraper',
                            'üß†': 'llm-brain',
                            'üñ•Ô∏è': 'server-config',
                            'üìß': 'email-sender',
                            'üìù': 'form-handler',
                            'üîó': 'webhook'
                        };
                        
                        const type = typeMap[nodeIcon];
                        if (type) {
                            createWorkflowNode(type, x, y);
                            saveState();
                        }
                    }
                    break;
            }
        });
    });

    // Canvas actions
    document.querySelectorAll('.canvas-actions .btn').forEach((btn, index) => {
        btn.addEventListener('click', function() {
            const actions = ['save', 'preview', 'deploy'];
            const action = actions[index];
            
            switch(action) {
                case 'save':
                    // Collect all node data
                    const nodes = [];
                    document.querySelectorAll('.workflow-node').forEach(node => {
                        const nodeData = {
                            id: node.dataset.nodeId,
                            type: node.querySelector('.node-title').textContent,
                            position: {
                                x: parseInt(node.style.left),
                                y: parseInt(node.style.top)
                            },
                            // Collect input values
                            inputs: []
                        };
                        
                        node.querySelectorAll('.node-input, .node-select').forEach(input => {
                            nodeData.inputs.push({
                                type: input.tagName.toLowerCase(),
                                value: input.value,
                                placeholder: input.placeholder
                            });
                        });
                        
                        nodes.push(nodeData);
                    });
                    
                    const workflowData = {
                        nodes: nodes,
                        connections: connections
                    };
                    
                    console.log('Saving workflow:', workflowData);
                    // Here you would send the data to your Django backend
                    alert('Workflow saved successfully!');
                    break;
                    
                case 'preview':
                    alert('Opening preview mode...');
                    break;
                    
                case 'deploy':
                    alert('Deploying chatbot...');
                    break;
            }
        });
    });

    // Auto-save functionality
    let autoSaveTimer;
    function scheduleAutoSave() {
        clearTimeout(autoSaveTimer);
        autoSaveTimer = setTimeout(() => {
            // Auto-save logic here
            console.log('Auto-saving...');
        }, 30000); // Auto-save every 30 seconds
    }

    // Trigger auto-save on changes
    document.addEventListener('input', scheduleAutoSave);
    document.addEventListener('change', scheduleAutoSave);

    // Keyboard shortcuts
    document.addEventListener('keydown', function(e) {
        if (e.ctrlKey || e.metaKey) {
            switch(e.key) {
                case 's':
                    e.preventDefault();
                    document.querySelector('.canvas-actions .btn-secondary').click();
                    break;
                case 'z':
                    e.preventDefault();
                    if (e.shiftKey) {
                        redo();
                    } else {
                        undo();
                    }
                    break;
                case 'c':
                    e.preventDefault();
                    document.querySelector('.toolbar-btn:nth-child(4)').click();
                    break;
                case 'Delete':
                case 'Backspace':
                    e.preventDefault();
                    document.querySelector('.toolbar-btn:nth-child(3)').click();
                    break;
            }
        }
    });

    // Manual connection drawing (optional - for manual connections)
    let isConnecting = false;
    let connectionStart = null;
    let tempLine = null;

    document.addEventListener('click', function(e) {
        if (e.target.classList.contains('connection-point')) {
            e.stopPropagation();
            
            if (!isConnecting) {
                // Start connection
                isConnecting = true;
                connectionStart = e.target;
                connectionStart.style.background = '#3b82f6';
                connectionStart.style.transform = 'scale(1.2)';
            } else {
                // Complete connection
                const connectionEnd = e.target;
                const startNode = connectionStart.closest('.workflow-node');
                const endNode = connectionEnd.closest('.workflow-node');
                
                if (startNode && endNode && startNode !== endNode) {
                    const fromNodeId = startNode.dataset.nodeId;
                    const toNodeId = endNode.dataset.nodeId;
                    
                    // Check if connection already exists
                    const existingConnection = connections.find(conn => 
                        (conn.from === fromNodeId && conn.to === toNodeId) ||
                        (conn.from === toNodeId && conn.to === fromNodeId)
                    );
                    
                    if (!existingConnection) {
                        createConnection(fromNodeId, toNodeId);
                        saveState();
                    }
                }
                
                // Reset connection state
                isConnecting = false;
                if (connectionStart) {
                    connectionStart.style.background = '';
                    connectionStart.style.transform = '';
                }
                connectionStart = null;
            }
        } else if (isConnecting) {
            // Cancel connection
            isConnecting = false;
            if (connectionStart) {
                connectionStart.style.background = '';
                connectionStart.style.transform = '';
            }
            connectionStart = null;
        }
    });

    // Initialize with initial state
    setTimeout(() => {
        saveState(); // Save initial empty state
        
        if (document.querySelectorAll('.workflow-node').length === 0) {
            // Show tooltip or guide
            const tooltip = document.createElement('div');
            tooltip.innerHTML = `
                <div style="position: absolute; top: 200px; left: 50%; transform: translateX(-50%); 
                           background: var(--surface); border: 1px solid var(--primary); 
                           border-radius: 8px; padding: 16px; max-width: 300px; z-index: 100;
                           box-shadow: var(--shadow-lg);">
                    <h3 style="margin: 0 0 8px 0; color: var(--primary);">üöÄ Get Started</h3>
                    <p style="margin: 0; color: var(--text-secondary); font-size: 14px;">
                        Drag components from the left panel onto the canvas to build your chatbot workflow!
                        <br><br>
                        <strong>‚ú® New Features:</strong><br>
                        ‚Ä¢ Auto-connect nearby nodes<br>
                        ‚Ä¢ Undo/Redo with Ctrl+Z/Ctrl+Shift+Z<br>
                        ‚Ä¢ Click connection points for manual connections
                    </p>
                    <button onclick="this.parentElement.remove()" 
                            style="margin-top: 12px; padding: 6px 12px; background: var(--primary); 
                                   color: white; border: none; border-radius: 4px; cursor: pointer;">
                        Got it!
                    </button>
                </div>
            `;
            workflowCanvas.appendChild(tooltip);
        }
    }, 1000);
});
</script>


<!-- your actions script  -->
 <script>
    // Action Tracker Script
document.addEventListener('DOMContentLoaded', function() {
    const actionsContainer = document.querySelector('.actions-list');
    let actionCounter = 0;
    
    // Track different types of actions
    function addAction(type, description, category = 'Action') {
        actionCounter++;
        const timestamp = new Date().toLocaleTimeString('en-US', { 
            hour12: false, 
            hour: '2-digit', 
            minute: '2-digit',
            second: '2-digit'
        });
        
        const actionItem = document.createElement('div');
        actionItem.className = 'action-item';
        actionItem.innerHTML = `
            <div class="action-content">
                <div class="action-indicator ${type}"></div>
                <div class="action-details">
                    <span class="action-description">${description}</span>
                    <div class="action-meta">
                        <span class="action-category">${category}</span>
                        <span class="action-time">${timestamp}</span>
                    </div>
                </div>
            </div>
        `;
        
        // Add to top of list
        actionsContainer.insertBefore(actionItem, actionsContainer.firstChild);
        
        // Limit to 10 actions
        if (actionsContainer.children.length > 10) {
            actionsContainer.removeChild(actionsContainer.lastChild);
        }
        
        // Highlight new action
        actionItem.classList.add('new-action');
        setTimeout(() => {
            actionItem.classList.remove('new-action');
        }, 2000);
    }
    
    // Track node creation
    const originalCreateWorkflowNode = window.createWorkflowNode;
    if (typeof createWorkflowNode === 'function') {
        window.createWorkflowNode = function(type, x, y) {
            const result = originalCreateWorkflowNode.call(this, type, x, y);
            const nodeNames = {
                'bot-config': 'Bot Configuration',
                'knowledge-base': 'Knowledge Base', 
                'web-scraper': 'Web Scraper',
                'llm-brain': 'LLM Brain',
                'server-config': 'Server Setup',
                'email-sender': 'Email Sender',
                'form-handler': 'Form Handler',
                'webhook': 'Webhook'
            };
            addAction('create', `Added ${nodeNames[type]} node`, 'Node');
            return result;
        };
    }
    
    // Track drag and drop
    document.addEventListener('drop', function(e) {
        if (e.target.id === 'workflowCanvas' || e.target.closest('#workflowCanvas')) {
            const draggedType = document.querySelector('.component-item[style*="opacity: 0.5"]');
            if (draggedType) {
                const componentName = draggedType.querySelector('.component-name').textContent;
                setTimeout(() => {
                    addAction('drag', `Dragged ${componentName} to canvas`, 'Canvas');
                }, 100);
            }
        }
    });
    
    // Track node movements
    let dragStartTime = null;
    document.addEventListener('mousedown', function(e) {
        if (e.target.closest('.workflow-node')) {
            dragStartTime = Date.now();
        }
    });
    
    document.addEventListener('mouseup', function(e) {
        if (dragStartTime && e.target.closest('.workflow-node')) {
            const dragDuration = Date.now() - dragStartTime;
            if (dragDuration > 100) { // Only count as movement if dragged for more than 100ms
                const nodeName = e.target.closest('.workflow-node').querySelector('.node-title').textContent;
                addAction('move', `Moved ${nodeName} node`, 'Layout');
            }
            dragStartTime = null;
        }
    });
    
    // Track connections
    const originalCreateConnection = window.createConnection;
    if (typeof createConnection === 'function') {
        window.createConnection = function(fromNodeId, toNodeId) {
            const result = originalCreateConnection.call(this, fromNodeId, toNodeId);
            const fromNode = document.querySelector(`[data-node-id="${fromNodeId}"]`);
            const toNode = document.querySelector(`[data-node-id="${toNodeId}"]`);
            if (fromNode && toNode) {
                const fromName = fromNode.querySelector('.node-title').textContent;
                const toName = toNode.querySelector('.node-title').textContent;
                addAction('connect', `Connected ${fromName} ‚Üí ${toName}`, 'Flow');
            }
            return result;
        };
    }
    
    // Track input changes
    document.addEventListener('input', function(e) {
        if (e.target.classList.contains('node-input') || e.target.classList.contains('node-select')) {
            const node = e.target.closest('.workflow-node');
            if (node) {
                const nodeName = node.querySelector('.node-title').textContent;
                const fieldType = e.target.placeholder || e.target.tagName.toLowerCase();
                addAction('edit', `Updated ${nodeName} configuration`, 'Config');
            }
        }
    });
    
    // Track toolbar actions
    document.addEventListener('click', function(e) {
        if (e.target.classList.contains('toolbar-btn')) {
            const actions = ['Undo', 'Redo', 'Delete', 'Copy'];
            const btnIndex = Array.from(e.target.parentElement.children).indexOf(e.target);
            if (actions[btnIndex]) {
                addAction('tool', `Used ${actions[btnIndex]} action`, 'Tool');
            }
        }
        
        // Track canvas actions
        if (e.target.classList.contains('btn') && e.target.closest('.canvas-actions')) {
            const btnText = e.target.textContent.trim();
            addAction('action', `${btnText} workflow`, 'Workflow');
        }
        
        // Track node selection
        if (e.target.closest('.workflow-node')) {
            const nodeName = e.target.closest('.workflow-node').querySelector('.node-title').textContent;
            addAction('select', `Selected ${nodeName}`, 'Node');
        }
        
        // Track zoom actions
        if (e.target.classList.contains('zoom-btn')) {
            const zoomActions = ['Zoom Out', 'Zoom In', 'Reset Zoom'];
            const btnIndex = Array.from(e.target.parentElement.children).indexOf(e.target);
            if (zoomActions[btnIndex]) {
                addAction('zoom', zoomActions[btnIndex], 'View');
            }
        }
    });
    
    // Track keyboard shortcuts
    document.addEventListener('keydown', function(e) {
        if (e.ctrlKey || e.metaKey) {
            const shortcuts = {
                's': 'Save workflow',
                'z': e.shiftKey ? 'Redo action' : 'Undo action',
                'c': 'Copy node'
            };
            
            if (shortcuts[e.key]) {
                addAction('shortcut', shortcuts[e.key], 'Keyboard');
            }
        }
        
        if (e.key === 'Delete' || e.key === 'Backspace') {
            const selected = document.querySelector('.workflow-node.selected');
            if (selected) {
                addAction('shortcut', 'Delete node', 'Keyboard');
            }
        }
    });
    
    // Track component palette interactions
    document.addEventListener('dragstart', function(e) {
        if (e.target.classList.contains('component-item')) {
            const componentName = e.target.querySelector('.component-name').textContent;
            addAction('pick', `Selected ${componentName} component`, 'Component');
        }
    });
    
    // Track toggle switches
    document.addEventListener('click', function(e) {
        if (e.target.classList.contains('toggle-switch')) {
            const isActive = e.target.classList.contains('active');
            addAction('toggle', `${isActive ? 'Disabled' : 'Enabled'} setting`, 'Config');
        }
    });
    
    // Track model selection
    document.addEventListener('click', function(e) {
        if (e.target.classList.contains('model-card')) {
            const modelName = e.target.querySelector('h3').textContent;
            addAction('select', `Selected ${modelName} model`, 'Model');
        }
    });
    
    // Initial welcome message
    setTimeout(() => {
        addAction('system', 'Workflow builder initialized', 'System');
    }, 500);
});
 </script>
 <style>
.actions-list {
    max-height: 500px;
    overflow-y: auto;
    border: 1px solid var(--border);
    border-radius: 8px;
    background: var(--surface);
    padding: 8px;
    margin-top: 8px;
}

.action-item {
    background: var(--surface-hover);
    border: 1px solid var(--border-light);
    border-radius: 6px;
    padding: 10px;
    margin-bottom: 6px;
    transition: all 0.2s ease;
    animation: slideIn 0.3s ease;
}

.action-item:last-child {
    margin-bottom: 0;
}

.action-item.new-action {
    border-color: var(--primary);
    box-shadow: 0 0 0 2px rgba(110, 142, 251, 0.1);
    transform: scale(1.01);
}

.action-content {
    display: flex;
    align-items: center;
    gap: 10px;
}

.action-indicator {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    flex-shrink: 0;
    background: var(--text-muted);
}

.action-indicator.create { background: var(--success); }
.action-indicator.edit { background: var(--warning); }
.action-indicator.move { background: var(--primary); }
.action-indicator.connect { background: var(--accent); }
.action-indicator.delete { background: var(--error); }
.action-indicator.select { background: var(--primary-light); }
.action-indicator.system { background: var(--secondary); }
.action-indicator.tool { background: var(--text-muted); }
.action-indicator.zoom { background: var(--text-muted); }
.action-indicator.shortcut { background: var(--text-muted); }
.action-indicator.pick { background: var(--primary); }
.action-indicator.drag { background: var(--primary); }
.action-indicator.toggle { background: var(--secondary); }
.action-indicator.action { background: var(--accent); }

.action-details {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 4px;
}

.action-description {
    font-size: 13px;
    color: var(--text);
    font-weight: 500;
    line-height: 1.4;
}

.action-meta {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 8px;
}

.action-category {
    font-size: 10px;
    color: var(--text-muted);
    background: var(--surface-light);
    padding: 2px 6px;
    border-radius: 4px;
    text-transform: uppercase;
    font-weight: 600;
    letter-spacing: 0.5px;
}

.action-time {
    font-size: 10px;
    color: var(--text-muted);
    font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
}

.actions-list:empty::before {
    content: "Your actions will appear here...";
    color: var(--text-muted);
    font-size: 12px;
    font-style: italic;
    display: block;
    text-align: center;
    padding: 20px;
}

@keyframes slideIn {
    from {
        opacity: 0;
        transform: translateY(-10px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

/* Scrollbar styling */
.actions-list::-webkit-scrollbar {
    width: 6px;
}

.actions-list::-webkit-scrollbar-track {
    background: var(--surface-light);
    border-radius: 3px;
}

.actions-list::-webkit-scrollbar-thumb {
    background: var(--border-light);
    border-radius: 3px;
}

.actions-list::-webkit-scrollbar-thumb:hover {
    background: var(--text-muted);
}
</style>


<!-- Responsiveness code ----------------------------------------- -->
 <style>
    /* Responsive Media Queries for Chatbot Builder */

/* Tablet and smaller desktop screens */
@media (max-width: 1024px) {
    .component-palette {
        width: 240px;
    }
    
    .properties-panel {
        width: 280px;
    }
    
    .workflow-node {
        min-width: 220px;
        padding: 16px;
    }
    
    .canvas-header {
        padding: 12px 16px;
    }
    
    .canvas-actions {
        gap: 8px;
    }
    
    .btn {
        padding: 6px 12px;
        font-size: 13px;
    }
}

/* Small tablets and large phones */
@media (max-width: 800px) {
    .builder-container {
        flex-direction: column;
        height: 100vh;
    }
    
    /* Mobile header with collapsible panels */
    .mobile-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        background: var(--surface);
        border-bottom: 1px solid var(--border);
        padding: 12px 16px;
        position: sticky;
        top: 0;
        z-index: 100;
    }
    
    .mobile-title {
        font-size: 16px;
        font-weight: 600;
        color: var(--text);
    }
    
    .mobile-controls {
        display: flex;
        gap: 8px;
    }
    
    .mobile-btn {
        padding: 8px 12px;
        background: var(--surface-light);
        border: 1px solid var(--border);
        border-radius: 6px;
        color: var(--text);
        font-size: 12px;
        cursor: pointer;
    }
    
    .mobile-btn.active {
        background: var(--primary);
        color: white;
    }
    
    /* Transform side panels into mobile sheets */
    .component-palette,
    .properties-panel {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: var(--surface);
        z-index: 200;
        transform: translateX(-100%);
        transition: transform 0.3s ease;
        overflow-y: auto;
    }
    
    .component-palette.active,
    .properties-panel.active {
        transform: translateX(0);
    }
    
    .properties-panel {
        transform: translateX(100%);
    }
    
    .properties-panel.active {
        transform: translateX(0);
    }
    
    /* Mobile panel headers */
    .mobile-panel-header {
        display: flex;
        justify-content: between;
        align-items: center;
        padding: 16px;
        border-bottom: 1px solid var(--border);
        background: var(--surface);
        position: sticky;
        top: 0;
        z-index: 10;
    }
    
    .mobile-close-btn {
        background: none;
        border: none;
        color: var(--text);
        font-size: 20px;
        cursor: pointer;
        padding: 8px;
        border-radius: 4px;
    }
    
    .mobile-close-btn:hover {
        background: var(--surface-hover);
    }
    
    /* Canvas adjustments */
    .canvas-container {
        flex: 1;
        height: calc(100vh - 60px);
    }
    
    .canvas-header {
        display: none; /* Hide on mobile, replaced by mobile-header */
    }
    
    .canvas-workspace {
        height: 100%;
    }
    
    .workflow-canvas {
        padding: 20px;
    }
    
    /* Workflow nodes mobile optimization */
    .workflow-node {
        min-width: 200px;
        padding: 12px;
        font-size: 14px;
    }
    
    .node-icon {
        width: 28px;
        height: 28px;
        font-size: 14px;
    }
    
    .node-title {
        font-size: 14px;
    }
    
    .node-content {
        font-size: 13px;
    }
    
    .node-input,
    .node-select {
        padding: 8px 10px;
        font-size: 14px;
    }
    
    /* Floating toolbar adjustments */
    .floating-toolbar {
        top: 10px;
        left: 10px;
        transform: none;
        flex-wrap: wrap;
        max-width: calc(100% - 20px);
    }
    
    .toolbar-btn {
        padding: 6px 8px;
        font-size: 12px;
    }
    
    /* Zoom controls */
    .zoom-controls {
        bottom: 10px;
        right: 10px;
    }
    
    .zoom-btn {
        width: 32px;
        height: 32px;
        font-size: 16px;
    }
    
    /* Component palette mobile */
    .palette-header {
        padding: 0 0 16px 0;
    }
    
    .component-item {
        padding: 12px;
        margin-bottom: 8px;
    }
    
    .component-icon {
        width: 20px;
        height: 20px;
        font-size: 11px;
    }
    
    .component-name {
        font-size: 13px;
    }
    
    .component-desc {
        font-size: 11px;
    }
    
    /* Properties panel mobile */
    .property-input,
    .property-textarea {
        padding: 10px;
        font-size: 14px;
    }
    
    .property-label {
        font-size: 13px;
    }
    
    .model-card {
        padding: 12px;
    }
    
    .model-name {
        font-size: 13px;
    }
    
    .model-desc {
        font-size: 11px;
    }
}

/* Mobile phones */
@media (max-width: 480px) {
    .workflow-node {
        min-width: 180px;
        padding: 10px;
    }
    
    .node-icon {
        width: 24px;
        height: 24px;
        font-size: 12px;
    }
    
    .node-title {
        font-size: 13px;
    }
    
    .node-content {
        font-size: 12px;
    }
    
    .node-input,
    .node-select {
        padding: 6px 8px;
        font-size: 13px;
    }
    
    .floating-toolbar {
        position: fixed;
        top: auto;
        bottom: 60px;
        left: 10px;
        right: 10px;
        justify-content: center;
        gap: 4px;
    }
    
    .toolbar-btn {
        padding: 8px 6px;
        font-size: 11px;
        flex: 1;
        text-align: center;
    }
    
    .zoom-controls {
        bottom: 10px;
        right: 10px;
        gap: 4px;
    }
    
    .zoom-btn {
        width: 28px;
        height: 28px;
        font-size: 14px;
    }
    
    .component-palette,
    .properties-panel {
        padding: 16px;
    }
    
    .component-category {
        margin-bottom: 20px;
    }
    
    .component-item {
        padding: 10px;
    }
    
    .property-group {
        margin-bottom: 20px;
    }
    
    .mobile-btn {
        padding: 6px 10px;
        font-size: 11px;
    }
    
    .workflow-canvas {
        padding: 15px;
    }
}

/* Extra small screens */
@media (max-width: 360px) {
    .workflow-node {
        min-width: 160px;
        padding: 8px;
    }
    
    .mobile-header {
        padding: 10px 12px;
    }
    
    .mobile-title {
        font-size: 14px;
    }
    
    .mobile-btn {
        padding: 4px 8px;
        font-size: 10px;
    }
    
    .toolbar-btn {
        padding: 6px 4px;
        font-size: 10px;
    }
    
    .workflow-canvas {
        padding: 10px;
    }
    
    .component-palette,
    .properties-panel {
        padding: 12px;
    }
}

/* Touch-specific improvements */
@media (hover: none) and (pointer: coarse) {
    .component-item,
    .workflow-node,
    .connection-point,
    .btn,
    .toolbar-btn,
    .zoom-btn {
        touch-action: manipulation;
    }
    
    .component-item:active,
    .workflow-node:active,
    .btn:active,
    .toolbar-btn:active {
        transform: scale(0.98);
    }
    
    .connection-point {
        width: 16px;
        height: 16px;
        border-width: 3px;
    }
    
    .connection-point:hover {
        transform: scale(1.2);
    }
    
    /* Increase touch targets */
    .mobile-close-btn {
        padding: 12px;
        font-size: 24px;
    }
    
    .toggle-switch {
        width: 48px;
        height: 28px;
    }
    
    .toggle-slider {
        width: 24px;
        height: 24px;
    }
    
    .toggle-switch.active .toggle-slider {
        transform: translateX(20px);
    }
}

/* Landscape orientation on mobile */
@media (max-width: 800px) and (orientation: landscape) {
    .builder-container {
        flex-direction: row;
    }
    
    .component-palette,
    .properties-panel {
        width: 280px;
        height: 100vh;
        transform: translateX(-100%);
    }
    
    .properties-panel {
        transform: translateX(100%);
    }
    
    .canvas-container {
        height: 100vh;
    }
    
    .mobile-header {
        display: none;
    }
    
    .canvas-header {
        display: flex;
    }
    
    .floating-toolbar {
        position: absolute;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        bottom: auto;
        right: auto;
    }
}

/* Dark mode adjustments for mobile */
@media (max-width: 800px) and (prefers-color-scheme: dark) {
    .mobile-header {
        background: var(--surface);
        border-bottom-color: var(--border);
    }
    
    .mobile-panel-header {
        background: var(--surface);
        border-bottom-color: var(--border);
    }
}

/* Print styles */
@media print {
    .component-palette,
    .properties-panel,
    .floating-toolbar,
    .zoom-controls,
    .canvas-header {
        display: none !important;
    }
    
    .canvas-container {
        width: 100% !important;
        height: auto !important;
    }
    
    .workflow-canvas {
        position: static !important;
        background: white !important;
    }
    
    .workflow-node {
        break-inside: avoid;
        border-color: #000 !important;
        background: white !important;
        color: #000 !important;
    }
}
 </style>
 <script>
    // Mobile Responsive JavaScript for Chatbot Builder

document.addEventListener('DOMContentLoaded', function() {
    // Create mobile header and controls
    function createMobileInterface() {
        if (window.innerWidth <= 800) {
            // Create mobile header if it doesn't exist
            if (!document.querySelector('.mobile-header')) {
                const mobileHeader = document.createElement('div');
                mobileHeader.className = 'mobile-header';
                mobileHeader.innerHTML = `
                    <div class="mobile-title">ü§ñ Bot Builder</div>
                    <div class="mobile-controls">
                        <button class="mobile-btn" data-panel="components">Components</button>
                        <button class="mobile-btn" data-panel="properties">Properties</button>
                        <button class="mobile-btn" data-action="save">Save</button>
                    </div>
                `;
                
                // Insert mobile header at the beginning of main content
                const mainContent = document.getElementById('mainContent');
                mainContent.insertBefore(mobileHeader, mainContent.firstChild);
            }
            
            // Add mobile close buttons to panels
            addMobilePanelHeaders();
            
            // Add mobile event listeners
            addMobileEventListeners();
        }
    }
    
    // Add mobile panel headers with close buttons
    function addMobilePanelHeaders() {
        const componentPalette = document.querySelector('.component-palette');
        const propertiesPanel = document.querySelector('.properties-panel');
        
        if (componentPalette && !componentPalette.querySelector('.mobile-panel-header')) {
            const header = document.createElement('div');
            header.className = 'mobile-panel-header';
            header.innerHTML = `
                <div class="palette-title">ü§ñ Components</div>
                <button class="mobile-close-btn" data-close="components">√ó</button>
            `;
            componentPalette.insertBefore(header, componentPalette.firstChild);
        }
        
        if (propertiesPanel && !propertiesPanel.querySelector('.mobile-panel-header')) {
            const header = document.createElement('div');
            header.className = 'mobile-panel-header';
            header.innerHTML = `
                <div class="properties-title">‚öôÔ∏è Properties</div>
                <button class="mobile-close-btn" data-close="properties">√ó</button>
            `;
            propertiesPanel.insertBefore(header, propertiesPanel.firstChild);
        }
    }
    
    // Add mobile event listeners
    function addMobileEventListeners() {
        // Mobile panel toggle buttons
        document.querySelectorAll('.mobile-btn[data-panel]').forEach(btn => {
            btn.addEventListener('click', function() {
                const panel = this.dataset.panel;
                toggleMobilePanel(panel);
            });
        });
        
        // Mobile close buttons
        document.querySelectorAll('.mobile-close-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                const panel = this.dataset.close;
                closeMobilePanel(panel);
            });
        });
        
        // Mobile save button
        const mobileSaveBtn = document.querySelector('.mobile-btn[data-action="save"]');
        if (mobileSaveBtn) {
            mobileSaveBtn.addEventListener('click', function() {
                // Trigger the main save functionality
                const mainSaveBtn = document.querySelector('.canvas-actions .btn-secondary');
                if (mainSaveBtn) {
                    mainSaveBtn.click();
                }
            });
        }
        
        // Close panels when clicking outside
        document.addEventListener('click', function(e) {
            if (window.innerWidth <= 800) {
                const componentPalette = document.querySelector('.component-palette');
                const propertiesPanel = document.querySelector('.properties-panel');
                
                if (componentPalette && componentPalette.classList.contains('active') &&
                    !componentPalette.contains(e.target) &&
                    !e.target.closest('.mobile-btn[data-panel="components"]')) {
                    closeMobilePanel('components');
                }
                
                if (propertiesPanel && propertiesPanel.classList.contains('active') &&
                    !propertiesPanel.contains(e.target) &&
                    !e.target.closest('.mobile-btn[data-panel="properties"]')) {
                    closeMobilePanel('properties');
                }
            }
        });
        
        // Handle escape key to close panels
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape' && window.innerWidth <= 800) {
                closeMobilePanel('components');
                closeMobilePanel('properties');
            }
        });
    }
    
    // Toggle mobile panel
    function toggleMobilePanel(panelType) {
        const panel = document.querySelector(panelType === 'components' ? '.component-palette' : '.properties-panel');
        const btn = document.querySelector(`.mobile-btn[data-panel="${panelType}"]`);
        
        if (panel && btn) {
            // Close other panel first
            const otherPanel = panelType === 'components' ? '.properties-panel' : '.component-palette';
            const otherBtn = document.querySelector(`.mobile-btn[data-panel="${panelType === 'components' ? 'properties' : 'components'}"]`);
            
            document.querySelector(otherPanel)?.classList.remove('active');
            otherBtn?.classList.remove('active');
            
            // Toggle current panel
            panel.classList.toggle('active');
            btn.classList.toggle('active');
        }
    }
    
    // Close mobile panel
    function closeMobilePanel(panelType) {
        const panel = document.querySelector(panelType === 'components' ? '.component-palette' : '.properties-panel');
        const btn = document.querySelector(`.mobile-btn[data-panel="${panelType}"]`);
        
        if (panel && btn) {
            panel.classList.remove('active');
            btn.classList.remove('active');
        }
    }
    
    // Enhanced touch handling for workflow nodes
    function enhanceTouchHandling() {
        let touchStartTime = 0;
        let touchStartPos = { x: 0, y: 0 };
        let isLongPress = false;
        
        document.querySelectorAll('.workflow-node').forEach(node => {
            // Touch start
            node.addEventListener('touchstart', function(e) {
                touchStartTime = Date.now();
                touchStartPos = {
                    x: e.touches[0].clientX,
                    y: e.touches[0].clientY
                };
                isLongPress = false;
                
                // Long press detection
                setTimeout(() => {
                    if (touchStartTime > 0) {
                        isLongPress = true;
                        // Show context menu or selection
                        this.classList.add('selected');
                        // Haptic feedback if available
                        if (navigator.vibrate) {
                            navigator.vibrate(50);
                        }
                    }
                }, 500);
            });
            
            // Touch move
            node.addEventListener('touchmove', function(e) {
                if (touchStartTime > 0) {
                    const deltaX = Math.abs(e.touches[0].clientX - touchStartPos.x);
                    const deltaY = Math.abs(e.touches[0].clientY - touchStartPos.y);
                    
                    // If moved significantly, it's a drag
                    if (deltaX > 10 || deltaY > 10) {
                        touchStartTime = 0; // Cancel long press
                    }
                }
            });
            
            // Touch end
            node.addEventListener('touchend', function(e) {
                const touchDuration = Date.now() - touchStartTime;
                
                if (touchDuration < 200 && !isLongPress) {
                    // Quick tap - select node
                    document.querySelectorAll('.workflow-node').forEach(n => {
                        n.classList.remove('selected');
                    });
                    this.classList.add('selected');
                }
                
                touchStartTime = 0;
                isLongPress = false;
            });
        });
    }
    
    // Optimize canvas for mobile
    function optimizeCanvasForMobile() {
        const canvas = document.querySelector('.workflow-canvas');
        if (canvas && window.innerWidth <= 800) {
            // Adjust minimum zoom for mobile
            const zoomButtons = document.querySelectorAll('.zoom-btn');
            if (zoomButtons.length >= 3) {
                zoomButtons[2].addEventListener('click', function() {
                    // Fit to screen on mobile
                    const nodes = document.querySelectorAll('.workflow-node');
                    if (nodes.length > 0) {
                        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                        
                        nodes.forEach(node => {
                            const rect = node.getBoundingClientRect();
                            const canvasRect = canvas.getBoundingClientRect();
                            const x = rect.left - canvasRect.left;
                            const y = rect.top - canvasRect.top;
                            
                            minX = Math.min(minX, x);
                            minY = Math.min(minY, y);
                            maxX = Math.max(maxX, x + rect.width);
                            maxY = Math.max(maxY, y + rect.height);
                        });
                        
                        const contentWidth = maxX - minX;
                        const contentHeight = maxY - minY;
                        const canvasWidth = canvas.offsetWidth - 40; // Account for padding
                        const canvasHeight = canvas.offsetHeight - 40;
                        
                        const scaleX = canvasWidth / contentWidth;
                        const scaleY = canvasHeight / contentHeight;
                        const scale = Math.min(scaleX, scaleY, 1); // Don't zoom in beyond 100%
                        
                        canvas.style.transform = `scale(${scale})`;
                        canvas.style.transformOrigin = 'top left';
                    }
                });
            }
        }
    }
    
    // Handle orientation change
    function handleOrientationChange() {
        setTimeout(() => {
            // Close mobile panels on orientation change
            if (window.innerWidth <= 800) {
                closeMobilePanel('components');
                closeMobilePanel('properties');
            }
            
            // Recalculate layout
            createMobileInterface();
            optimizeCanvasForMobile();
        }, 100);
    }
    
    // Prevent zoom on double tap (but allow intentional zoom)
    function preventUnintentionalZoom() {
        let lastTouchEnd = 0;
        document.addEventListener('touchend', function(e) {
            const now = Date.now();
            if (now - lastTouchEnd <= 300) {
                e.preventDefault();
            }
            lastTouchEnd = now;
        }, false);
    }
    
    // Initialize mobile interface
    createMobileInterface();
    optimizeCanvasForMobile();
    enhanceTouchHandling();
    preventUnintentionalZoom();
    
    // Handle window resize
    window.addEventListener('resize', function() {
        createMobileInterface();
        optimizeCanvasForMobile();
    });
    
    // Handle orientation change
    window.addEventListener('orientationchange', handleOrientationChange);
    
    // Add swipe gesture for mobile panels
    let touchStartX = 0;
    let touchStartY = 0;
    
    document.addEventListener('touchstart', function(e) {
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
    });
    
    document.addEventListener('touchmove', function(e) {
        if (window.innerWidth <= 800) {
            const touchEndX = e.touches[0].clientX;
            const touchEndY = e.touches[0].clientY;
            const deltaX = touchEndX - touchStartX;
            const deltaY = touchEndY - touchStartY;
            
            // Swipe right to open components (from left edge)
            if (deltaX > 50 && Math.abs(deltaY) < 50 && touchStartX < 50) {
                toggleMobilePanel('components');
            }
            
            // Swipe left to open properties (from right edge)
            if (deltaX < -50 && Math.abs(deltaY) < 50 && touchStartX > window.innerWidth - 50) {
                toggleMobilePanel('properties');
            }
        }
    });
});
 </script>
{% endblock content %}